package org.dwfa.maven;

import java.io.File;
import java.io.FileWriter;
import java.io.Writer;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.dwfa.cement.ArchitectonicAuxiliary;
import org.dwfa.cement.DocumentAuxiliary;
import org.dwfa.cement.HL7;
import org.dwfa.cement.QueueType;
import org.dwfa.cement.RefsetAuxiliary;
import org.dwfa.cement.SNOMEDExtension;
import org.dwfa.tapi.I_ConceptualizeLocally;
import org.dwfa.tapi.I_DescribeConceptLocally;
import org.dwfa.tapi.impl.LocalFixedTerminology;
import org.dwfa.tapi.impl.MemoryTermServer;
import org.dwfa.tapi.spec.TaxonomySpec;

/**
 * Export the specified CEMeNT (Common Enumerations and Metadata to Normalize Terminology) taxonomies in
 * the ACE format (with branch ids and effective dates for standard components--concepts, descriptions, relationships).
 * 
 * @goal export-cement-taxonomy
 * @phase process-resources
 */

public class ExportCementTaxonomyInAceFormat extends AbstractMojo {
   
   /**
    * An enumeration of the taxonomies that can be exported via this maven plugin goal. 
    * @author kec
    *
    */
   public enum TAXONOMIES { 
      /**
       * The standard taxonomy required by the ACE environment to normalize descriptions, relationships, and other
       * types treated as enumerations by SNOMED, and implicit in many other terminologies. 
       */
      ACE_AUXILIARY, 
      /**
       * A taxonomy for organizing sections of clinical documentation. 
       */
      DOCUMENT_AUXILIARY, 
      /**
       * A taxonomy that contains the HL7 entity name part concepts
       */
      HL7, 
      /**
       * A taxonomy that contains queue types use by the workflow environemnt during queue service discovery. 
       */
      QUEUE_TYPE, 
      /**
       * A taxonomy that provides the metadata necessary to implement refsets. 
       */
      REFSET_AUXILIARY, 
      /**
       * A taxonomy that extends snomed, by adding Gregorian date as a unit of time. 
       */
      SNOMED_EXTENSION};
      
      /**
       * Taxonomies to export. Must be one or more of the Taxonomies provided in the <code>TAXONOMIES enum</code> in this class.
       * 
       * @parameter
       * @required
      */
      private String[] taxonomies;
      

   /**
    * Location of the build directory.
    * 
    * @parameter expression="${project.build.directory}"
    * @required
    */
   private File outputDirectory;

   /**
    * Location of the build directory.
    * 
    * @parameter
    */
   private String output;
   
   /**
    * Effective date for exported content - defaults to now if not set
    * 
    * @parameter
    */
   private Date effectiveDate;
   
   /**
    * The maven session
    * 
    * @parameter expression="${session}"
    * @required
    */
   private MavenSession session;

   /**
    * Specification of the concepts to exclude from this export
    * @parameter
    */
   private TaxonomySpec[] exclusions;
   
   /**
    * Only execute this mojo for one of the allowed goals. 
    * This will prevent unexpected execution of plugins when
    * other goals are executed such as eclipse:eclipse or
    * site:site. 
    * 
    * There may be better ways to do this... If you find one, 
    * please let us know :-)
    */
   
   private String[] allowedGoals = new String[] { "install","deploy" };

   public void execute() throws MojoExecutionException, MojoFailureException {
      
      if (MojoUtil.allowedGoal(getLog(), session.getGoals(), allowedGoals)) {
         getLog().info("Exporting cement taxonomies");
         try {
            String prefix;
            if (output == null) {
               prefix = outputDirectory.getCanonicalPath() + File.separatorChar + 
                  "generated-resources" + File.separatorChar + 
                  "cement" + File.separatorChar;
            } else {
               output = output.replace('/', File.separatorChar);
               prefix = output + File.separator;
            }
			MemoryTermServer mts = new MemoryTermServer();
			if (effectiveDate != null) {
				mts.setEffectiveDate(effectiveDate);
			}
            LocalFixedTerminology.setStore(mts);
            mts.setGenerateIds(true);
            for (String tstr: taxonomies) {
               TAXONOMIES t = TAXONOMIES.valueOf(tstr);
               switch (t) {
               case ACE_AUXILIARY:
                  ArchitectonicAuxiliary aa = new ArchitectonicAuxiliary();
                  aa.addToMemoryTermServer(mts);
                  break;
               case DOCUMENT_AUXILIARY:
                  DocumentAuxiliary da = new DocumentAuxiliary();
                  da.addToMemoryTermServer(mts);
                  break;
               case HL7:
                  HL7 hl7 =  new HL7();
                  hl7.addToMemoryTermServer(mts);
                  break;
               case QUEUE_TYPE:
                  QueueType qt = new QueueType();
                  qt.addToMemoryTermServer(mts);
                  break;
               case REFSET_AUXILIARY:
                  RefsetAuxiliary ra = new RefsetAuxiliary();
                  ra.addToMemoryTermServer(mts);
                  break;
               case SNOMED_EXTENSION:
                  SNOMEDExtension se = new SNOMEDExtension();
                  se.addToMemoryTermServer(mts);
                  break;

               default:
                  throw new Exception("Don't know how to handle taxonomy: " + t);
               }
            }
            
            
            File directory = new File(prefix);
            directory.mkdirs();
            File conceptFile = new File(directory, "concepts.txt");
            File descFile = new File(directory, "descriptions.txt");
            File relFile = new File(directory, "relationships.txt");
            File rootsFile = new File(directory, "roots.txt");
            File extTypeFile = new File(directory, "extensions.txt");
            File altIdFile = new File(directory, "alt_ids.txt");



            mts.setGenerateIds(false);
            mts.setExclusions(exclusions);

            Writer altIdWriter = new FileWriter(altIdFile);

            Writer conceptWriter = new FileWriter(conceptFile);
            mts.writeConcepts(conceptWriter, altIdWriter, MemoryTermServer.FILE_FORMAT.ACE);
            conceptWriter.close();

            Writer descWriter = new FileWriter(descFile);
            mts.writeDescriptions(descWriter, altIdWriter, MemoryTermServer.FILE_FORMAT.ACE);
            descWriter.close();

            Writer relWriter = new FileWriter(relFile);
            mts.writeRelationships(relWriter, altIdWriter, MemoryTermServer.FILE_FORMAT.ACE);
            relWriter.close();

            Writer rootsWriter = new FileWriter(rootsFile);
            mts.writeRoots(rootsWriter, MemoryTermServer.FILE_FORMAT.ACE);
            rootsWriter.close();

            Writer extensionTypeWriter = new FileWriter(extTypeFile);
            mts.writeExtensionTypes(extensionTypeWriter, altIdWriter, MemoryTermServer.FILE_FORMAT.ACE);
            extensionTypeWriter.close();

            I_ConceptualizeLocally[] descTypeOrder = new I_ConceptualizeLocally[] {
                    mts.getConcept(mts.getNid(ArchitectonicAuxiliary.Concept.EXTENSION_TABLE.getUids())) };
            List<I_ConceptualizeLocally> descTypePriorityList = Arrays.asList(descTypeOrder);

            for (I_ConceptualizeLocally extensionType: mts.getExtensionTypes()) {
                I_DescribeConceptLocally typeDesc = extensionType.getDescription(descTypePriorityList);
                File extensionFile = new File(directory, typeDesc.getText() + ".txt");
                Writer extensionWriter = new FileWriter(extensionFile);
                mts.writeExtension(extensionType, extensionWriter, altIdWriter, MemoryTermServer.FILE_FORMAT.ACE);
                extensionWriter.close();
            }
         } catch (Exception e) {
            throw new MojoExecutionException(e.getMessage(), e);
         }
      }
   }
   
 
}
